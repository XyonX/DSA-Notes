// Online C++ compiler to run C++ program online
#include <iostream>
#include <bits/stdc++.h>

using namespace std;

//SOME RECURSION BASED PROBLEM

//thsi is the version i implemnted
//it has precisio isue so wont be passing all trest case in leetcode
double pow(int i,int num, int exponent){
    if (i>=exponent-1){
        return num;
    }
    return num*pow(i+1,num,exponent);
}

//this is the fixed version
//i dodnt wrote it 
//written or fixed by ai that passed all tesrt case 
class Solution {
public:
    double pow(int i, double num, int exponent){
        if (i >= exponent - 1){
            return num;
        }
        return num * pow(i + 1, num, exponent);
    }

    double myPow(double x, int n) {
        if (n == 0) return 1;
        
        // Handle negative exponents
        bool isNegative = (n < 0);
        long long exp = abs((long long)n);

        double result = pow(0, x, exp);
        return isNegative ? 1.0 / result : result;
    }
};

//basic is prme helper
bool isPrime(int number){
    for(int i=2;i<number/2;i++){
        if(number%2==0){
            return false;
        }
    }
    return true;
}

//good number rule is 
//even index must have even digit
//odd index must have prime digit

bool goodNumber(int i,int number,int n){
    if(i>=n){
        return true;
    }
    int d=number%10;
    if(i%2==0){
        
        if(d%2==0){
            return goodNumber(i+1,number/10,n);
        }else{
            return false;
        }
    }else{
        if(isPrime(d)){
             return goodNumber(i+1,number/10,n);
        }else{
            return false;
        }
    }
}

//i thinkl this is a more oiptimizedf version for the leetcode 
//not implemted by me
//just for furture ref and it uses probably mah based formula
class Solution {
public:
    static constexpr int MOD = 1e9 + 7;

    long long power(long long base, long long exponent) {
        long long result = 1;
        while (exponent > 0) {
            if (exponent % 2 == 1)
                result = (result * base) % MOD;
            base = (base * base) % MOD;
            exponent /= 2;
        }
        return result;
    }

    int countGoodNumbers(long long n) {
        long long evenPositions = (n + 1) / 2; // indexes 0, 2, 4...
        long long oddPositions = n / 2;        // indexes 1, 3, 5...

        long long total = (power(5, evenPositions) * power(4, oddPositions)) % MOD;
        return static_cast<int>(total);
    }
};

int main() {
    cout<<goodNumber(0,820,3);
}