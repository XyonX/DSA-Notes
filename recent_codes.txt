ğŸ§  DSA Notes: Find Single Number Using XOR
ğŸ”¹ Problem Statement:
Given a non-empty array of integers, where every element appears twice except one, find the element that appears only once.

Constraints:

Must run in O(n) time

Use only O(1) extra space

ğŸ” Key Insight: Use XOR
XOR properties:

a ^ a = 0 â†’ same numbers cancel out

a ^ 0 = a â†’ XOR with 0 has no effect

XOR is commutative and associative â†’ order doesn't matter

âœ… So if we XOR all elements:

Duplicates cancel each other

Only the single element remains

ğŸ“ Dry Run Example 1:
cpp
Copy
Edit
Input: nums = [2, 3, 5, 3, 2]

Step-by-step XOR:
res = 0
res ^= 2 â†’ 0 ^ 2 = 2  
res ^= 3 â†’ 2 ^ 3 = 1  
res ^= 5 â†’ 1 ^ 5 = 4  
res ^= 3 â†’ 4 ^ 3 = 7  
res ^= 2 â†’ 7 ^ 2 = 5

âœ… Final Answer: 5
ğŸ“ Dry Run Example 2:
cpp
Copy
Edit
Input: nums = [4, 1, 2, 1, 2]

res = 0  
res ^= 4 â†’ 4  
res ^= 1 â†’ 5  
res ^= 2 â†’ 7  
res ^= 1 â†’ 6  
res ^= 2 â†’ 4

âœ… Final Answer: 4


class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res=nums[0];
        for(int i=1;i<nums.size();i++){
            res^=nums[i];
        }
        return res;
    }
};


class Solution {
public:

//this soltuion is corect
//but not effienct
//and didntr passed all the test case in leetcode
    // int maxProfit(vector<int>& prices) {
    //     int maxProfit=0;
    //     for(int i=0;i<prices.size();i++){
    //         for(int j=i+1;j<prices.size();j++){
    //             if(prices[j]-prices[i]>maxProfit){
    //                 maxProfit=prices[j]-prices[i];
    //             }
                
    //         }
    //     }
    //     return maxProfit;
    // }


//this one is a greedy solution and passed all the test case 
//adn optimnal
        int maxProfit(vector<int>& prices) {
        int minPrice=prices[0];
        int maxProfit=0;
        for(int i=1;i<prices.size();i++){
            maxProfit=max(maxProfit,prices[i]-minPrice);
            minPrice=min(prices[i],minPrice);
        }
        return maxProfit;
    }
};