# 01 OOP INSTANCE STORAGE AND POINTER

Alright — let’s make this as small, clear, and code-backed as possible.
We’ll split it into **four scenarios** based on what object you create (Base vs. Derived) and where you store it (Base pointer vs. Derived pointer).

---

## **Class Setup**

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int x = 10;
    virtual void show() { cout << "Base\n"; }
};

class Derived : public Base {
public:
    int y = 20;
    void show() override { cout << "Derived\n"; }
};
```

---

## **Scenario 1: Create Base → Store in Base pointer** ✅ Safe

```cpp
Base* b = new Base;
b->show(); // Base
// Only Base members accessible
delete b;
```

* **Safe**: Exact match of type and pointer.
* **Memory size**: only `Base`.

---

## **Scenario 2: Create Base → Store in Derived pointer** ❌ Unsafe

```cpp
// Derived* d = new Base; // ❌ Compile error (needs explicit cast)
Derived* d = (Derived*) new Base; // Forced cast - very unsafe!
d->show(); // Undefined behavior (pretending Base is Derived)
delete d;  // Likely crash
```

* **Danger**: Base doesn’t have `y`, but we pretend it does — memory corruption risk.
* **C++**: Will not allow implicit assignment, but C-style cast bypasses the check.

---

## **Scenario 3: Create Derived → Store in Derived pointer** ✅ Safe

```cpp
Derived* d = new Derived;
d->show(); // Derived
cout << d->y; // OK
delete d;
```

* **Safe**: Exact match again.
* **Memory size**: includes Base + Derived parts.

---

## **Scenario 4: Create Derived → Store in Base pointer** ✅ Safe (with limits)

```cpp
Base* b = new Derived;
b->show(); // Derived (polymorphism)
cout << b->x; // OK
// b->y; // ❌ Not accessible (pointer type is Base)
delete b;
```

* **Reason**: Useful for polymorphism (e.g., passing `Derived` to a function expecting `Base*`).
* **Memory**: Still allocates full Derived object, but Base pointer only sees Base interface.

---

## **Casting Back**

```cpp
Base* b = new Derived;

// ✅ Safe if it really points to Derived
Derived* d1 = dynamic_cast<Derived*>(b);
if (d1) cout << d1->y;

// ❌ Unsafe if it doesn't actually point to Derived
Base* b2 = new Base;
Derived* d2 = dynamic_cast<Derived*>(b2); // returns nullptr
```

* **`static_cast`**: Checks at compile time, no runtime safety.
* **`dynamic_cast`**: Checks at runtime, returns `nullptr` if wrong type (only works with polymorphic types — i.e., classes with `virtual`).

---

If you want, I can make you a **single diagram** that shows exactly where the memory lives and which casts are safe vs. unsafe. That might lock this in your head.

//02 CASTING OF CPP OOP
Alright — in C++ there are **four main casting operators**, each with a different purpose and set of rules.
We’ll go step-by-step so you can see *why* each exists, how it behaves, and when you’d use it.

---

## **1. `static_cast`**

**Purpose:**

* Used for conversions that are known at *compile time* and are considered *safe* by the programmer.
* Commonly used for:

  * Converting between related types in inheritance (but *only downcast if you’re sure* the object is of that type).
  * Numeric type conversions (`int` → `double`, etc.).
  * Removing `const`-ness (but only with care).

**Key points:**

* Checked **at compile time** (no runtime check).
* Dangerous if you downcast to the wrong type — the compiler won’t stop you, but the program can behave unpredictably.

**Example:**

```cpp
class Base { };
class Derived : public Base { };

Base* b = new Derived();
Derived* d = static_cast<Derived*>(b); // Works, but unsafe if b isn't actually Derived.
```

---

## **2. `dynamic_cast`**

**Purpose:**

* Used for *safe* type conversions **within a class hierarchy**.
* Performs a **runtime check** to ensure the cast is valid.
* Works only on pointers and references to polymorphic classes (must have at least one `virtual` function).

**Key points:**

* If cast fails:

  * For pointers: returns `nullptr`.
  * For references: throws `std::bad_cast`.
* Slightly slower than `static_cast` because it uses RTTI (Run-Time Type Information).
* Safer for downcasting in inheritance hierarchies.

**Example:**

```cpp
class Base { public: virtual ~Base() {} };
class Derived : public Base { };

Base* b = new Base();
Derived* d = dynamic_cast<Derived*>(b); // returns nullptr, because b isn't Derived
```

---

## **3. `const_cast`**

**Purpose:**

* Used to **add or remove `const` or `volatile` qualifiers**.
* Commonly used to call functions that incorrectly lack `const` in their parameter list, or to work with legacy APIs.

**Key points:**

* Does **not** change the actual object in memory — only removes the compiler's protection.
* If you try to modify an object that was originally declared `const`, behavior is **undefined**.

**Example:**

```cpp
void printMessage(char* msg) { /* ... */ }

const char* text = "Hello";
printMessage(const_cast<char*>(text)); // Removes const
```

---

## **4. `reinterpret_cast`**

**Purpose:**

* Used for **low-level reinterpreting** of bit patterns — essentially telling the compiler “treat this memory as if it were of another type.”
* Commonly used in:

  * Converting between unrelated pointer types.
  * Casting integral types to pointers (and vice versa).

**Key points:**

* Very dangerous — no checks, no type-safety.
* Often used in systems programming, networking, or when interfacing with hardware.

**Example:**

```cpp
int a = 65;
char* p = reinterpret_cast<char*>(&a); // Treats int's memory as char[]
```

---

## Quick Summary Table

| Cast Type          | Checks at Compile Time? | Checks at Run Time? | Main Use Case                                                  | Safety Level               |
| ------------------ | ----------------------- | ------------------- | -------------------------------------------------------------- | -------------------------- |
| `static_cast`      | ✅ Yes                   | ❌ No                | Type-safe, known conversions; base ↔ derived (safe if correct) | Medium                     |
| `dynamic_cast`     | ✅ Yes                   | ✅ Yes               | Safe downcasting in polymorphic hierarchies                    | High                       |
| `const_cast`       | ✅ Yes                   | ❌ No                | Add/remove const/volatile qualifiers                           | Medium (danger if misused) |
| `reinterpret_cast` | ✅ Yes                   | ❌ No                | Bit-level reinterpreting of memory                             | Low (dangerous)            |

---

If you want, I can also **diagram how these behave in an inheritance tree** so you see why `static_cast` and `dynamic_cast` differ when moving up and down between base/derived types.
Do you want me to draw that next?
