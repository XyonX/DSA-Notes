#include <bits/stdc++.h>
using namespace std;

// Simple DFS (prints each node when first visited)
void dfs(int u, const vector<vector<int>>& adj, vector<int>& visited) {
    if (visited[u]) return;
    visited[u] = 1;
    cout << u << ' ';
    for (int v : adj[u]) {
        dfs(v, adj, visited);
    }
}

int main() {
    // Example directed graph with 9 nodes: 0..8
    // ASCII diagram (two components)
    //
    // Component A:
    //  0 ──► 1 ──► 3 ──► 5
    //  │               ▲
    //  │               │
    //  └──► 2 ──► 4 ───┘
    //               │
    //               └──► 6
    //
    // Edges:
    //  0 -> 1, 2
    //  1 -> 3
    //  2 -> 4
    //  3 -> 5
    //  4 -> 5, 6
    //  5 -> 2          (creates a cycle 2 -> 4 -> 5 -> 2)
    //  6 -> (none)
    //
    // Component B:
    //  7 ──► 8
    //
    // Note:
    // - This is a DIRECTED graph. For undirected graphs, add edges both ways.

    int n = 9;
    vector<vector<int>> adj(n);

    // Build edges for Component A
    adj[0] = {1, 2};
    adj[1] = {3};
    adj[2] = {4};
    adj[3] = {5};
    adj[4] = {5, 6};
    adj[5] = {2};
    // adj[6] = {}; // implicit empty

    // Build edges for Component B
    adj[7] = {8};
    // adj[8] = {}; // implicit empty

    // 1) Run DFS from a chosen start node
    {
        vector<int> visited(n, 0);
        int start = 0;
        cout << "DFS starting from node " << start << ": ";
        dfs(start, adj, visited);
        cout << "\n";
        // Expected order (given adjacency above): 0 1 3 5 2 4 6
        // (Order can vary if you change adjacency list ordering)
    }

    // 2) Run DFS over the whole graph to cover disconnected components
    {
        vector<int> visited(n, 0);
        int comp = 0;
        cout << "Full graph DFS by components:\n";
        for (int u = 0; u < n; ++u) {
            if (!visited[u]) {
                cout << "Component " << (++comp) << ": ";
                dfs(u, adj, visited);
                cout << "\n";
            }
        }
        // Expected:
        // Component 1: 0 1 3 5 2 4 6
        // Component 2: 7 8
    }

    return 0;
}