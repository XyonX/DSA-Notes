#include <bits/stdc++.h>\nusing namespace std;\n\n// Define the structure of a tree node\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n\n    Node(int val) {\n        data = val;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\n// Algorithm to check if a bt is bst\nbool isBst(Node*root,long min, long max){\n    if (root==nullptr)return true;\n    \n    if(root->data >= max || root->data <=min)return false;\n\n    return isBst(root->left,min,root->data) && isBst(root->right,root->data,max);\n}\n\nvoid testIsBST() {\n    // ✅ Valid BST:\n    //         10\n    //        /  \\\n    //       5   15\n    //          /  \\\n    //         12  20\n    Node* bstRoot = new Node(10);\n    bstRoot->left = new Node(5);\n    bstRoot->right = new Node(15);\n    bstRoot->right->left = new Node(12);\n    bstRoot->right->right = new Node(20);\n\n    cout << \"BST Check (Valid): \" << (isBst(bstRoot, LONG_MIN, LONG_MAX) ? \"True\" : \"False\") << endl;\n\n    // ❌ Invalid BST:\n    //         10\n    //        /  \\\n    //       5   8   ← violates BST rule\n    Node* nonBstRoot = new Node(10);\n    nonBstRoot->left = new Node(5);\n    nonBstRoot->right = new Node(8);\n\n    cout << \"BST Check (Invalid): \" << (isBst(nonBstRoot, LONG_MIN, LONG_MAX) ? \"True\" : \"False\") << endl;\n}